// Generated by: gen
// TypeWriter: slice
// Directive: +gen on BlockedUser

package models

import (
	"errors"
	"math/rand"
)

// BlockedUserSlice is a slice of type BlockedUser. Use it where you would use []BlockedUser.
type BlockedUserSlice []BlockedUser

// Where returns a new BlockedUserSlice whose elements return true for func. See: http://clipperhouse.github.io/gen/#Where
func (rcv BlockedUserSlice) Where(fn func(BlockedUser) bool) (result BlockedUserSlice) {
	for _, v := range rcv {
		if fn(v) {
			result = append(result, v)
		}
	}
	return result
}

// Count gives the number elements of BlockedUserSlice that return true for the passed func. See: http://clipperhouse.github.io/gen/#Count
func (rcv BlockedUserSlice) Count(fn func(BlockedUser) bool) (result int) {
	for _, v := range rcv {
		if fn(v) {
			result++
		}
	}
	return
}

// GroupByString groups elements into a map keyed by string. See: http://clipperhouse.github.io/gen/#GroupBy
func (rcv BlockedUserSlice) GroupByString(fn func(BlockedUser) string) map[string]BlockedUserSlice {
	result := make(map[string]BlockedUserSlice)
	for _, v := range rcv {
		key := fn(v)
		result[key] = append(result[key], v)
	}
	return result
}

// Shuffle returns a shuffled copy of BlockedUserSlice, using a version of the Fisher-Yates shuffle. See: http://clipperhouse.github.io/gen/#Shuffle
func (rcv BlockedUserSlice) Shuffle() BlockedUserSlice {
	numItems := len(rcv)
	result := make(BlockedUserSlice, numItems)
	copy(result, rcv)
	for i := 0; i < numItems; i++ {
		r := i + rand.Intn(numItems-i)
		result[r], result[i] = result[i], result[r]
	}
	return result
}

// Any verifies that one or more elements of BlockedUserSlice return true for the passed func. See: http://clipperhouse.github.io/gen/#Any
func (rcv BlockedUserSlice) Any(fn func(BlockedUser) bool) bool {
	for _, v := range rcv {
		if fn(v) {
			return true
		}
	}
	return false
}

// AverageInt sums int over all elements and divides by len(BlockedUserSlice). See: http://clipperhouse.github.io/gen/#Average
func (rcv BlockedUserSlice) AverageInt(fn func(BlockedUser) int) (result int, err error) {
	l := len(rcv)
	if l == 0 {
		err = errors.New("cannot determine Average[int] of zero-length BlockedUserSlice")
		return
	}
	for _, v := range rcv {
		result += fn(v)
	}
	result = result / int(l)
	return
}
